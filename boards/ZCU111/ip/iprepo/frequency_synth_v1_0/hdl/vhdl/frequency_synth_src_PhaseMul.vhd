-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\frequency_synth\frequency_synth_src_PhaseMul.vhd
-- Created: 2020-10-19 10:03:31
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: frequency_synth_src_PhaseMul
-- Source Path: frequency_synth/Frequency Synthesis/NCO Generator 0/NCO HDL Optimized/PhaseMul
-- Hierarchy Level: 3
-- 
-- Wave form Generation Component
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.frequency_synth_src_Frequency_Synthesis_pkg.ALL;

ENTITY frequency_synth_src_PhaseMul IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        pInc                              :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32
        validIn                           :   IN    std_logic;
        reset_1                           :   IN    std_logic;
        phasevector                       :   OUT   vector_of_std_logic_vector32(0 TO 3)  -- sfix32 [4]
        );
END frequency_synth_src_PhaseMul;


ARCHITECTURE rtl OF frequency_synth_src_PhaseMul IS

  -- Signals
  SIGNAL pInc_signed                      : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL radix2_factor0                   : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor3                     : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay                : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL radix2_factor1                   : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay_1              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL valid_dly                        : std_logic;
  SIGNAL accInit_accReg                   : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL accInit_state                    : std_logic;  -- ufix1
  SIGNAL accInit_accReg_next              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL accInit_state_next               : std_logic;  -- ufix1
  SIGNAL sel                              : std_logic;
  SIGNAL acc_reg                          : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL ZERO                             : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay_2              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay_3              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL phase_adder                      : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL output_reg                       : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay_4              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay_5              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL phase_adder_1                    : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL output_reg_1                     : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL base_factor_delay_6              : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL phase_adder_2                    : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL output_reg_2                     : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL phasevector_tmp                  : vector_of_signed32(0 TO 3);  -- sfix32 [4]

BEGIN
  pInc_signed <= signed(pInc);

  radix2_factor0 <= pInc_signed sll 1;

  base_factor3 <= pInc_signed + radix2_factor0;

  delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      base_factor_delay <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF reset_1 = '1' THEN
          base_factor_delay <= to_signed(0, 32);
        ELSIF validIn = '1' THEN
          base_factor_delay <= base_factor3;
        END IF;
      END IF;
    END IF;
  END PROCESS delay_process;


  radix2_factor1 <= pInc_signed sll 2;

  delay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      base_factor_delay_1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF reset_1 = '1' THEN
          base_factor_delay_1 <= to_signed(0, 32);
        ELSIF validIn = '1' THEN
          base_factor_delay_1 <= radix2_factor1;
        END IF;
      END IF;
    END IF;
  END PROCESS delay_1_process;


  delay_balance_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      valid_dly <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        valid_dly <= validIn;
      END IF;
    END IF;
  END PROCESS delay_balance_process;


  -- accInit
  accInit_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      accInit_accReg <= to_signed(0, 32);
      accInit_state <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF reset_1 = '1' THEN
          accInit_accReg <= to_signed(0, 32);
          accInit_state <= '0';
        ELSE 
          accInit_accReg <= accInit_accReg_next;
          accInit_state <= accInit_state_next;
        END IF;
      END IF;
    END IF;
  END PROCESS accInit_process;

  accInit_output : PROCESS (accInit_accReg, accInit_state, base_factor_delay, base_factor_delay_1,
       valid_dly)
  BEGIN
    accInit_accReg_next <= accInit_accReg;
    accInit_state_next <= accInit_state;
    CASE accInit_state IS
      WHEN '0' =>
        accInit_state_next <= '0';
        accInit_accReg_next <= to_signed(0, 32);
        IF valid_dly = '1' THEN 
          accInit_state_next <= '1';
          accInit_accReg_next <= base_factor_delay;
        END IF;
      WHEN '1' =>
        accInit_state_next <= '1';
        IF valid_dly = '1' THEN 
          accInit_accReg_next <= accInit_accReg + base_factor_delay_1;
        END IF;
      WHEN OTHERS => 
        accInit_state_next <= '0';
        accInit_accReg_next <= to_signed(0, 32);
    END CASE;
    sel <= accInit_state;
    acc_reg <= accInit_accReg;
  END PROCESS accInit_output;


  ZERO <= to_signed(0, 32);

  delay_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      base_factor_delay_2 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF reset_1 = '1' THEN
          base_factor_delay_2 <= to_signed(0, 32);
        ELSIF validIn = '1' THEN
          base_factor_delay_2 <= pInc_signed;
        END IF;
      END IF;
    END IF;
  END PROCESS delay_2_process;


  
  base_factor_delay_3 <= ZERO WHEN sel = '0' ELSE
      base_factor_delay_2;

  phase_adder <= acc_reg + base_factor_delay_3;

  delay_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output_reg <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        output_reg <= phase_adder;
      END IF;
    END IF;
  END PROCESS delay_3_process;


  delay_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      base_factor_delay_4 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF reset_1 = '1' THEN
          base_factor_delay_4 <= to_signed(0, 32);
        ELSIF validIn = '1' THEN
          base_factor_delay_4 <= radix2_factor0;
        END IF;
      END IF;
    END IF;
  END PROCESS delay_4_process;


  
  base_factor_delay_5 <= base_factor_delay_2 WHEN sel = '0' ELSE
      base_factor_delay_4;

  phase_adder_1 <= acc_reg + base_factor_delay_5;

  delay_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output_reg_1 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        output_reg_1 <= phase_adder_1;
      END IF;
    END IF;
  END PROCESS delay_5_process;


  
  base_factor_delay_6 <= base_factor_delay_4 WHEN sel = '0' ELSE
      base_factor_delay;

  phase_adder_2 <= acc_reg + base_factor_delay_6;

  delay_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      output_reg_2 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        output_reg_2 <= phase_adder_2;
      END IF;
    END IF;
  END PROCESS delay_6_process;


  phasevector_tmp(0) <= output_reg;
  phasevector_tmp(1) <= output_reg_1;
  phasevector_tmp(2) <= output_reg_2;
  phasevector_tmp(3) <= acc_reg;

  outputgen: FOR k IN 0 TO 3 GENERATE
    phasevector(k) <= std_logic_vector(phasevector_tmp(k));
  END GENERATE;

END rtl;

