-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\frequency_synth\frequency_synth_src_NCO_HDL_Optimized.vhd
-- Created: 2020-10-19 10:03:31
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: frequency_synth_src_NCO_HDL_Optimized
-- Source Path: frequency_synth/Frequency Synthesis/NCO Generator 0/NCO HDL Optimized
-- Hierarchy Level: 2
-- 
-- NCO HDL Optimized
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.frequency_synth_src_Frequency_Synthesis_pkg.ALL;

ENTITY frequency_synth_src_NCO_HDL_Optimized IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        inc                               :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        validIn                           :   IN    std_logic;
        sine                              :   OUT   vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En15 [4]
        cosine                            :   OUT   vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En15 [4]
        validOut                          :   OUT   std_logic
        );
END frequency_synth_src_NCO_HDL_Optimized;


ARCHITECTURE rtl OF frequency_synth_src_NCO_HDL_Optimized IS

  -- Component Declarations
  COMPONENT frequency_synth_src_PhaseMul
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          pInc                            :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32
          validIn                         :   IN    std_logic;
          reset_1                         :   IN    std_logic;
          phasevector                     :   OUT   vector_of_std_logic_vector32(0 TO 3)  -- sfix32 [4]
          );
  END COMPONENT;

  COMPONENT frequency_synth_src_WaveformGen
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          phaseIdx                        :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16
          sine                            :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          cosine                          :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En15
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : frequency_synth_src_PhaseMul
    USE ENTITY work.frequency_synth_src_PhaseMul(rtl);

  FOR ALL : frequency_synth_src_WaveformGen
    USE ENTITY work.frequency_synth_src_WaveformGen(rtl);

  -- Signals
  SIGNAL outsel_reg_reg                   : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL outsel                           : std_logic;
  SIGNAL outzero                          : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL inc_unsigned                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL pInc                             : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL reset_1                          : std_logic;
  SIGNAL phasevector                      : vector_of_std_logic_vector32(0 TO 3);  -- ufix32 [4]
  SIGNAL phasevector_signed               : vector_of_signed32(0 TO 3);  -- sfix32 [4]
  SIGNAL pOffset                          : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL alpha0_reg                       : vector_of_signed32(0 TO 1);  -- sfix32 [2]
  SIGNAL phase_delay                      : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL phaseoutputvector_reg            : vector_of_signed32(0 TO 3);  -- sfix32 [4]
  SIGNAL phaseoutputvector_reg_1          : vector_of_signed32(0 TO 3);  -- sfix32 [4]
  SIGNAL dither_phase_vector_reg          : vector_of_signed32(0 TO 3);  -- sfix32 [4]
  SIGNAL quantoutputvector                : vector_of_unsigned16(0 TO 3);  -- ufix16 [4]
  SIGNAL dout_4                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_1                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_2                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_3                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_4                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_5                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_6                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_4_7                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dout_bus                         : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL out_reg                          : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL sine_tmp                         : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL outzero_1                        : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL dout_bus_1                       : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL out_reg_1                        : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]
  SIGNAL cosine_tmp                       : vector_of_signed16(0 TO 3);  -- sfix16_En15 [4]

BEGIN
  u_pinc_mul : frequency_synth_src_PhaseMul
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              pInc => std_logic_vector(pInc),  -- sfix32
              validIn => validIn,
              reset_1 => reset_1,
              phasevector => phasevector  -- sfix32 [4]
              );

  u_wavegen_4 : frequency_synth_src_WaveformGen
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              phaseIdx => std_logic_vector(quantoutputvector(0)),  -- ufix16
              sine => dout_4,  -- sfix16_En15
              cosine => dout_4_1  -- sfix16_En15
              );

  u_wavegen_4_1 : frequency_synth_src_WaveformGen
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              phaseIdx => std_logic_vector(quantoutputvector(1)),  -- ufix16
              sine => dout_4_2,  -- sfix16_En15
              cosine => dout_4_3  -- sfix16_En15
              );

  u_wavegen_4_2 : frequency_synth_src_WaveformGen
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              phaseIdx => std_logic_vector(quantoutputvector(2)),  -- ufix16
              sine => dout_4_4,  -- sfix16_En15
              cosine => dout_4_5  -- sfix16_En15
              );

  u_wavegen_4_3 : frequency_synth_src_WaveformGen
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              phaseIdx => std_logic_vector(quantoutputvector(3)),  -- ufix16
              sine => dout_4_6,  -- sfix16_En15
              cosine => dout_4_7  -- sfix16_En15
              );

  outsel_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outsel_reg_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        outsel_reg_reg(0) <= validIn;
        outsel_reg_reg(1 TO 7) <= outsel_reg_reg(0 TO 6);
      END IF;
    END IF;
  END PROCESS outsel_reg_process;

  outsel <= outsel_reg_reg(7);

  outzero(0) <= to_signed(16#0000#, 16);
  outzero(1) <= to_signed(16#0000#, 16);
  outzero(2) <= to_signed(16#0000#, 16);
  outzero(3) <= to_signed(16#0000#, 16);

  inc_unsigned <= unsigned(inc);

  pInc <= signed(inc_unsigned);

  reset_1 <= '0';

  outputgen2: FOR k1 IN 0 TO 3 GENERATE
    phasevector_signed(k1) <= signed(phasevector(k1));
  END GENERATE;

  pOffset <= to_signed(0, 32);

  alpha0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha0_reg <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        alpha0_reg(0) <= pOffset;
        alpha0_reg(1) <= alpha0_reg(0);
      END IF;
    END IF;
  END PROCESS alpha0_process;

  phase_delay <= alpha0_reg(1);


  phaseoutputvector_reg_gen: FOR t_0 IN 0 TO 3 GENERATE
    phaseoutputvector_reg(t_0) <= phasevector_signed(t_0) + phase_delay;
  END GENERATE phaseoutputvector_reg_gen;


  alpha0_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      phaseoutputvector_reg_1 <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        phaseoutputvector_reg_1 <= phaseoutputvector_reg;
      END IF;
    END IF;
  END PROCESS alpha0_1_process;


  alpha0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dither_phase_vector_reg <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        dither_phase_vector_reg <= phaseoutputvector_reg_1;
      END IF;
    END IF;
  END PROCESS alpha0_2_process;



  quantoutputvector_gen: FOR k IN 0 TO 3 GENERATE
    quantoutputvector(k) <= unsigned(dither_phase_vector_reg(k)(31 DOWNTO 16));
  END GENERATE quantoutputvector_gen;


  dout_bus(0) <= signed(dout_4);
  dout_bus(1) <= signed(dout_4_2);
  dout_bus(2) <= signed(dout_4_4);
  dout_bus(3) <= signed(dout_4_6);

  
  out_reg <= outzero WHEN outsel = '0' ELSE
      dout_bus;

  c_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sine_tmp <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sine_tmp <= out_reg;
      END IF;
    END IF;
  END PROCESS c_process;


  outputgen1: FOR k1 IN 0 TO 3 GENERATE
    sine(k1) <= std_logic_vector(sine_tmp(k1));
  END GENERATE;

  outzero_1(0) <= to_signed(16#0000#, 16);
  outzero_1(1) <= to_signed(16#0000#, 16);
  outzero_1(2) <= to_signed(16#0000#, 16);
  outzero_1(3) <= to_signed(16#0000#, 16);

  dout_bus_1(0) <= signed(dout_4_1);
  dout_bus_1(1) <= signed(dout_4_3);
  dout_bus_1(2) <= signed(dout_4_5);
  dout_bus_1(3) <= signed(dout_4_7);

  
  out_reg_1 <= outzero_1 WHEN outsel = '0' ELSE
      dout_bus_1;

  c_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cosine_tmp <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        cosine_tmp <= out_reg_1;
      END IF;
    END IF;
  END PROCESS c_1_process;


  outputgen: FOR k1 IN 0 TO 3 GENERATE
    cosine(k1) <= std_logic_vector(cosine_tmp(k1));
  END GENERATE;

  -- validOut register
  validOut_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOut <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOut <= outsel;
      END IF;
    END IF;
  END PROCESS validOut_reg_process;


END rtl;

